import React, { useState, useCallback } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Button, Input, Select, Card, Alert, Spin, Typography, Switch, Form } from 'antd';
import { SettingOutlined, SaveOutlined, CheckCircleOutlined, InfoCircleOutlined, EyeInvisibleOutlined, EyeTwoTone } from '@ant-design/icons';
import { toast } from 'react-hot-toast';
import { api, handleApiError } from '../lib/api';

const { Text } = Typography;

interface AIModel {
  id: string;
  name: string;
  description: string;
  max_tokens: number;
  available: boolean;
}

interface AIConfig {
  default_model?: string;
  api_key_configured?: boolean;
}

interface AIConfigResponse {
  models: AIModel[];
  currentConfig: AIConfig;
}

interface UpdateConfigResponse {
  status: string;
  updates: {
    api_key_updated?: boolean;
    default_model_updated?: boolean;
    default_model?: string;
  };
}

const AISettings: React.FC = () => {
  const [apiKey, setApiKey] = useState('');
  const [selectedModel, setSelectedModel] = useState<string>('');
  const [showApiKey, setShowApiKey] = useState(false);
  const queryClient = useQueryClient();

  const fetchAIConfig = useCallback(async (): Promise<AIConfigResponse> => {
    try {
      const [modelsRes, configRes] = await Promise.all([
        api.get<Record<string, any>>('/ai/models'),
        api.get<AIConfig>('/ai/config/current')
      ]);
      
      // Transform the models data to match our interface
      const models = Object.entries(modelsRes.data).map(([id, model]) => ({
        id,
        name: model.name,
        description: model.description,
        max_tokens: model.max_tokens,
        available: model.available
      }));

      return {
        models,
        currentConfig: configRes.data
      };
    } catch (error) {
      const errorMessage = handleApiError(error, 'Failed to load AI settings');
      toast.error(errorMessage);
      throw error;
    }
  }, []);

  const { data: config, isLoading: isLoadingConfig } = useQuery<AIConfigResponse>({
    queryKey: ['ai-config'],
    queryFn: fetchAIConfig,
    onSuccess: (data) => {
      if (data?.currentConfig?.default_model) {
        setSelectedModel(data.currentConfig.default_model);
      }
    },
    retry: 1,
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 30 * 60 * 1000, // 30 minutes (cacheTime is now gcTime in newer versions)
  });

  // Update configuration mutation
  const updateConfig = useMutation({
    mutationFn: async (data: { apiKey?: string; defaultModel?: string }) => {
      const payload: Record<string, any> = {};
      if (data.apiKey !== undefined && data.apiKey.trim() !== '') {
        payload.api_key = data.apiKey.trim();
      }
      if (data.defaultModel !== undefined) {
        payload.default_model = data.defaultModel;
      }
      
      const response = await api.post<UpdateConfigResponse>('/ai/config', payload);
      return response.data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['ai-config'] });
      toast.success('AI settings updated successfully');
      
      // Clear the API key field if it was just saved
      if (data.updates?.api_key_updated) {
        setApiKey('');
      }
    },
    onError: (error: Error) => {
      const errorMessage = handleApiError(error, 'Failed to update settings');
      toast.error(errorMessage);
    }
  });

  const handleSave = useCallback(() => {
    if (!selectedModel) {
      toast.error('Please select a default AI model');
      return;
    }
    
    updateConfig.mutate({
      apiKey: apiKey || undefined,
      defaultModel: selectedModel
    });
  }, [selectedModel, apiKey, updateConfig]);

  const availableModels = config?.models || [];
  const isApiKeyConfigured = Boolean(config?.currentConfig?.api_key_configured);
  const currentModel = availableModels.find((m: AIModel) => m.id === selectedModel);

  if (isLoadingConfig) {
    return (
      <div className="flex justify-center items-center h-64">
        <Spin size="large" />
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto p-4">
      <Card 
        title={
          <div className="flex items-center">
            <SettingOutlined className="mr-2" />
            <span>AI Settings</span>
          </div>
        }
        className="shadow-lg"
      >
        <div className="space-y-6">
          <div>
            <h3 className="text-lg font-medium mb-2">OpenAI API Key</h3>
            <div className="flex items-center space-x-2">
              <Input.Password
                placeholder={isApiKeyConfigured ? '••••••••••••••••' : 'Enter your OpenAI API key'}
                value={apiKey}
                onChange={(e) => setApiKey(e.target.value)}
                iconRender={(visible) => (visible ? <EyeTwoTone /> : <EyeInvisibleOutlined />)}
                className="flex-1"
                disabled={updateConfig.isPending}
              />
              <Button 
                type="primary" 
                onClick={() => setShowApiKey(!showApiKey)}
                icon={showApiKey ? <EyeInvisibleOutlined /> : <EyeTwoTone />}
              />
            </div>
            {!isApiKeyConfigured && (
              <p className="text-sm text-gray-500 mt-1">
                Your API key is stored securely and only used to make requests to OpenAI's API.
              </p>
            )}
            {isApiKeyConfigured && !apiKey && (
              <div className="flex items-center text-green-600 mt-2">
                <CheckCircleOutlined className="mr-1" />
                <span>API key is configured</span>
              </div>
            )}
          </div>

          <div>
            <h3 className="text-lg font-medium mb-2">Default AI Model</h3>
            <Select
              className="w-full"
              value={selectedModel}
              onChange={(value) => setSelectedModel(value)}
              loading={isLoadingConfig}
              disabled={updateConfig.isPending || isLoadingConfig}
              optionLabelProp="label"
            >
              {availableModels.map((model) => (
                <Select.Option 
                  key={model.id} 
                  value={model.id}
                  disabled={!model.available}
                  label={
                    <span>
                      {model.name} {!model.available && '(Coming Soon)'}
                    </span>
                  }
                >
                  <div>
                    <div className="font-medium">
                      {model.name} {!model.available && '(Coming Soon)'}
                    </div>
                    <div className="text-xs text-gray-500">
                      {model.description} (max {model.max_tokens.toLocaleString()} tokens)
                    </div>
                  </div>
                </Select.Option>
              ))}
            </Select>
            {currentModel && (
              <div className="mt-2 text-sm text-gray-600">
                <InfoCircleOutlined className="mr-1" />
                {currentModel.description} (max {currentModel.max_tokens.toLocaleString()} tokens)
              </div>
            )}
          </div>

          <div className="pt-4 border-t border-gray-200">
            <div className="flex justify-between items-center">
              <div className="text-sm text-gray-500">
                {currentModel && (
                  <div className="flex items-center">
                    <InfoCircleOutlined className="mr-1" />
                    <Text type="secondary">
                      {currentModel.description} (max {currentModel.max_tokens.toLocaleString()} tokens)
                    </Text>
                  </div>
                )}
              </div>
              <Button
                type="primary"
                icon={<SaveOutlined />}
                onClick={handleSave}
                loading={updateConfig.isPending || isLoadingConfig}
                disabled={!selectedModel || updateConfig.isPending || isLoadingConfig}
              >
                Save Settings
              </Button>
            </div>
          </div>

          {updateConfig.isError && (
            <Alert
              message="Error"
              description={updateConfig.error?.message || 'Failed to update settings'}
              type="error"
              showIcon
              className="mt-4"
            />
          )}
        </div>
      </Card>
    </div>
  );
};

export default AISettings;
