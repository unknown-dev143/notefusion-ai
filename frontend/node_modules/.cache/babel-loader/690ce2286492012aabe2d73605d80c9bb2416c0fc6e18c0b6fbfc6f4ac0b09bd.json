{"ast":null,"code":"import{v4 as uuidv4}from'uuid';class LectureService{constructor(){this.currentLecture=null;this.lectureTimeout=null;this.LECTURE_TIMEOUT_MS=10*60*1000;// 10 minutes of inactivity\nthis.MIN_CONTENT_LENGTH=20;// Minimum chars to consider as valid note\n// Callback for when a new lecture is detected\nthis.onNewLecture=null;// Callback for when a lecture is marked as complete\nthis.onLectureComplete=null;}processNewContent(content,videoTitle){if(!content||content.length<this.MIN_CONTENT_LENGTH){return null;}const now=new Date();// Check if this is a new lecture\nif(!this.currentLecture||this.isNewLecture(content,now)){const prevLecture=this.currentLecture;// Mark previous lecture as complete if exists\nif(prevLecture){this.markLectureComplete(prevLecture);}// Create new lecture\nthis.currentLecture={id:uuidv4(),title:videoTitle||`Lecture ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`,content,timestamp:now,lectureNumber:this.getNextLectureNumber(),isComplete:false};// Notify about new lecture\nif(this.onNewLecture){this.onNewLecture(this.currentLecture);}}else{// Add to existing lecture\nif(this.currentLecture){this.currentLecture.content+=`\\n\\n${content}`;this.currentLecture.timestamp=now;}}// Reset the inactivity timer\nthis.resetInactivityTimer();return this.currentLecture;}markCurrentLectureComplete(){if(this.currentLecture&&!this.currentLecture.isComplete){this.markLectureComplete(this.currentLecture);this.currentLecture=null;}}markLectureComplete(lecture){if(lecture.isComplete)return;lecture.isComplete=true;if(this.onLectureComplete){this.onLectureComplete(lecture);}}isNewLecture(content,currentTime){if(!this.currentLecture)return true;const timeSinceLastUpdate=currentTime.getTime()-this.currentLecture.timestamp.getTime();// Consider it a new lecture if:\n// 1. More than 30 minutes since last update\n// 2. Content starts with a number (possible lecture number)\n// 3. Content contains lecture-related keywords\nconst hasLectureNumber=/^\\s*lecture\\s+\\d+/i.test(content)||/^\\s*\\d+\\s*[.:]/.test(content);const hasLectureKeywords=/lecture|class|chapter|unit|part/i.test(content);return timeSinceLastUpdate>30*60*1000||hasLectureNumber||hasLectureKeywords;}resetInactivityTimer(){if(this.lectureTimeout){clearTimeout(this.lectureTimeout);}this.lectureTimeout=setTimeout(()=>{if(this.currentLecture){this.markCurrentLectureComplete();}},this.LECTURE_TIMEOUT_MS);}getNextLectureNumber(){// In a real app, this would fetch from your database\n// For now, we'll use a simple counter\nreturn 1;// You'll want to implement proper lecture number tracking\n}}export const lectureService=new LectureService();","map":{"version":3,"names":["v4","uuidv4","LectureService","constructor","currentLecture","lectureTimeout","LECTURE_TIMEOUT_MS","MIN_CONTENT_LENGTH","onNewLecture","onLectureComplete","processNewContent","content","videoTitle","length","now","Date","isNewLecture","prevLecture","markLectureComplete","id","title","toLocaleDateString","toLocaleTimeString","timestamp","lectureNumber","getNextLectureNumber","isComplete","resetInactivityTimer","markCurrentLectureComplete","lecture","currentTime","timeSinceLastUpdate","getTime","hasLectureNumber","test","hasLectureKeywords","clearTimeout","setTimeout","lectureService"],"sources":["C:/Users/User/notefusion-ai/notefusion-ai/frontend/src/services/lectureService.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\n\nexport interface LectureNote {\n  id: string;\n  title: string;\n  content: string;\n  timestamp: Date;\n  lectureNumber?: number;\n  isComplete: boolean;\n  videoId?: string;\n}\n\nclass LectureService {\n  private currentLecture: LectureNote | null = null;\n  private lectureTimeout: NodeJS.Timeout | null = null;\n  private readonly LECTURE_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes of inactivity\n  private readonly MIN_CONTENT_LENGTH = 20; // Minimum chars to consider as valid note\n\n  // Callback for when a new lecture is detected\n  public onNewLecture: ((lecture: LectureNote) => void) | null = null;\n  \n  // Callback for when a lecture is marked as complete\n  public onLectureComplete: ((lecture: LectureNote) => void) | null = null;\n\n  public processNewContent(content: string, videoTitle?: string): LectureNote | null {\n    if (!content || content.length < this.MIN_CONTENT_LENGTH) {\n      return null;\n    }\n\n    const now = new Date();\n    \n    // Check if this is a new lecture\n    if (!this.currentLecture || this.isNewLecture(content, now)) {\n      const prevLecture = this.currentLecture;\n      \n      // Mark previous lecture as complete if exists\n      if (prevLecture) {\n        this.markLectureComplete(prevLecture);\n      }\n\n      // Create new lecture\n      this.currentLecture = {\n        id: uuidv4(),\n        title: videoTitle || `Lecture ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`,\n        content,\n        timestamp: now,\n        lectureNumber: this.getNextLectureNumber(),\n        isComplete: false,\n      };\n\n      // Notify about new lecture\n      if (this.onNewLecture) {\n        this.onNewLecture(this.currentLecture);\n      }\n    } else {\n      // Add to existing lecture\n      if (this.currentLecture) {\n        this.currentLecture.content += `\\n\\n${content}`;\n        this.currentLecture.timestamp = now;\n      }\n    }\n\n    // Reset the inactivity timer\n    this.resetInactivityTimer();\n    \n    return this.currentLecture;\n  }\n\n  public markCurrentLectureComplete(): void {\n    if (this.currentLecture && !this.currentLecture.isComplete) {\n      this.markLectureComplete(this.currentLecture);\n      this.currentLecture = null;\n    }\n  }\n\n  private markLectureComplete(lecture: LectureNote): void {\n    if (lecture.isComplete) return;\n    \n    lecture.isComplete = true;\n    if (this.onLectureComplete) {\n      this.onLectureComplete(lecture);\n    }\n  }\n\n  private isNewLecture(content: string, currentTime: Date): boolean {\n    if (!this.currentLecture) return true;\n    \n    const timeSinceLastUpdate = currentTime.getTime() - this.currentLecture.timestamp.getTime();\n    \n    // Consider it a new lecture if:\n    // 1. More than 30 minutes since last update\n    // 2. Content starts with a number (possible lecture number)\n    // 3. Content contains lecture-related keywords\n    const hasLectureNumber = /^\\s*lecture\\s+\\d+/i.test(content) || /^\\s*\\d+\\s*[.:]/.test(content);\n    const hasLectureKeywords = /lecture|class|chapter|unit|part/i.test(content);\n    \n    return timeSinceLastUpdate > 30 * 60 * 1000 || hasLectureNumber || hasLectureKeywords;\n  }\n\n  private resetInactivityTimer(): void {\n    if (this.lectureTimeout) {\n      clearTimeout(this.lectureTimeout);\n    }\n\n    this.lectureTimeout = setTimeout(() => {\n      if (this.currentLecture) {\n        this.markCurrentLectureComplete();\n      }\n    }, this.LECTURE_TIMEOUT_MS);\n  }\n\n  private getNextLectureNumber(): number {\n    // In a real app, this would fetch from your database\n    // For now, we'll use a simple counter\n    return 1; // You'll want to implement proper lecture number tracking\n  }\n}\n\nexport const lectureService = new LectureService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}